# URL Shortener Service - Design Note

## Database Choice

**MongoDB** was selected as the primary database for this URL shortener service due to several key advantages:

### Why i choose MongoDB?
1. **Schema Flexibility**: URL shortening services handle semi-structured data where each document has a consistent core structure but may evolve over time
2. **Write Performance**: MongoDB excels at high-volume insert operations which is crucial for generating short URLs
3. **Horizontal Scaling**: Built-in sharding capabilities allow for distributed data across multiple servers
4. **Document Model**: Natural fit for storing URL metadata and analytics data in nested structures
5. **TTL Indexes**: Built-in support for automatic document expiration (useful for temporary URLs)

### Schema Design:
- **Urls Collection**: Immutable mapping of shortId → longUrl with creation timestamp
- **Clicks Collection**: Time-series data of each redirect event
- **Referrers Collection**: Aggregated counts of referral domains for fast analytics
- **Analytics Collection**: Pre-aggregated summary data for quick dashboard access

## Caching Strategy

**Redis** is implemented as a caching layer to optimize read performance:

### Implementation:
1. **URL Resolution Cache**: ShortId → LongUrl mappings cached with 1-hour TTL
2. **Write-Through Pattern**: Cache is updated immediately after database writes
3. **Cache-Aside Pattern**: On reads, check cache first, then database, then repopulate cache
4. **Statistical Data**: Frequently accessed analytics data could be cached (future enhancement)

### Its Benefits:
- Reduces database load for frequently accessed URLs
- Improves redirect response times from ~100ms to ~5ms
- Handles traffic spikes more effectively

## Scalability Considerations

### Horizontal Scaling Strategies:
1. **Application Level**: Stateless application servers behind load balancer
2. **Database Level**: MongoDB sharding by shortId or snowflakeId
3. **Cache Level**: Redis Cluster for distributed caching
4. **CDN Integration**: For serving static assets and caching redirects at edge locations

### Performance Optimizations:
1. **Snowflake ID Generation**: Distributed ID generation avoids database sequencing bottlenecks
2. **Base62 Encoding**: Compact URL identifiers (shorter than UUIDs)
3. **Read/Write Separation**: Analytics writes don't block URL resolution reads
4. **Batched Writes**: For high-volume click tracking (future enhancement)

### Estimated Capacity:
- Single instance: ~1,000 requests/second
- With scaling: 10,000+ requests/second achievable
- ID generation: 10,000+ IDs/second per worker

## Trade-offs Made

### 1. **Consistency vs Performance**
- **Choice**: Eventual consistency for analytics data
- **Rationale**: URL resolution requires strong consistency, but analytics can be eventually consistent
- **Impact**: Analytics may show slightly stale data but redirects are always accurate

### 2. **Storage vs Computation**
- **Choice**: Pre-aggregated analytics collections
- **Rationale**: Faster read performance for dashboard at cost of additional storage
- **Impact**: Higher storage usage but sub-millisecond analytics queries

### 3. **Complexity vs Features**
- **Choice**: Simple per-IP rate limiting instead of sophisticated abuse prevention
- **Rationale**: Minimum viable product with basic protection
- **Impact**: Easier implementation but less comprehensive security

### 4. **Durability vs Speed**
- **Choice**: Fire-and-forget analytics writing
- **Rationale**: Click tracking shouldn't block URL redirection
- **Impact**: Potential minimal data loss during failures but faster redirects

## Future Enhancements

1. **Edge Caching**: CDN integration for global redirect performance
2. **Batched Analytics**: Kafka pipeline for high-volume click processing
3. **Custom Domains**: Support for custom short domains
4. **API Rate Limits**: Tiered rate limiting based on authentication
5. **URL Management**: Edit/delete capabilities with authentication
6. **QR Code Generation**: Native QR code support
7. **Expiring URLs**: TTL-based URL expiration



# API Documentation

## Base URL
`http://localhost:3000`

## Endpoints

### 1. Create Short URL
**POST** `/shorten`

**Request:**
```bash
curl -X POST http://localhost:3000/shorten \
  -H "Content-Type: application/json" \
  -d '{"url": "https://example.com/very/long/url"}'
```

**Response:**
```json
{
  "shortUrl": "http://localhost:3000/abc123",
  "shortId": "abc123"
}
```

### 2. Redirect to URL
**GET** `/:shortId`

**Request:**
```bash
curl -I http://localhost:3000/abc123
```

**Response:**
- HTTP 302 Redirect to original URL

### 3. Get URL Statistics
**GET** `/stats/:shortId`

**Request:**
```bash
curl http://localhost:3000/stats/abc123
```

**Response:**
```json
{
  "shortId": "abc123",
  "clickCount": 42,
  "lastAccessed": "2023-10-15T14:30:00.000Z",
  "topReferrers": [
    {"domain": "google.com", "count": 15},
    {"domain": "twitter.com", "count": 8}
  ],
  "recentClicks": [
    "2023-10-15T14:30:00.000Z",
    "2023-10-15T14:25:00.000Z"
  ]
}
```

### 4. Health Check
**GET** `/health`

**Request:**
```bash
curl http://localhost:3000/health
```

**Response:**
```json
{
  "status": "ok"
}
```

---

# Database Schema

## Collections

### 1. urls
javascript
{
  _id: ObjectId,
  shortId: String,        // Unique index
  longUrl: String,        // Required
  createdAt: Date,        // Default: now
  snowflakeId: String     // Unique index
}


### 2. clicks
```javascript
{
  _id: ObjectId,
  shortId: String,        // Indexed
  timestamp: Date,        // Default: now
  referrer: String,       // Optional
  ip: String              // Optional
}
```

### 3. referrers
```javascript
{
  _id: ObjectId,
  shortId: String,        // Compound index with domain
  domain: String,         // Compound index with shortId
  count: Number           // Default: 0
}
```

### 4. analytics
```javascript
{
  _id: ObjectId,
  shortId: String,        // Unique index
  clickCount: Number,     // Default: 0
  lastAccessed: Date      // Optional
}
```

---

# Local Development Setup

## Prerequisites
- Node.js 16+
- MongoDB 5+
- Redis (optional)

## Installation

1. **Clone repository**
   ```bash
   git clone <repository-url>
   cd url-shortener
   ```

2. **Install dependencies**
   ```bash
   npm install
   ```

3. **Set up environment variables**
   ```bash
   cp .env.example .env
   # Edit .env with your settings
   ```

4. **Start MongoDB**
   ```bash
   # macOS with Homebrew
   brew services start mongodb/brew/mongodb-community
   
   # Ubuntu
   sudo systemctl start mongod
   
   # Windows
   net start MongoDB
   ```

5. **Start Redis (optional)**
   ```bash
   # macOS with Homebrew
   brew services start redis
   
   # Ubuntu
   sudo systemctl start redis-server
   
   # Windows
   # Download and run Redis from https://redis.io/docs/getting-started/installation/install-redis-on-windows/
   ```

6. **Run the application**
   ```bash
   # Development mode with auto-restart
   npm run dev
   
   # Production mode
   npm start
   ```

7. **Access the application**
   - Web interface: http://localhost:3000
   - API base URL: http://localhost:3000

## Testing

Run the test suite:
```bash
npm test
```

## Environment Variables

| Variable | Default | Description |
|----------|---------|-------------|
| MONGO_URI | mongodb://localhost:27017/urlshortener | MongoDB connection string |
| REDIS_URL | null | Redis connection string (optional) |
| BASE_HOST | http://localhost:3000 | Base URL for short links |
| PORT | 3000 | Server port |